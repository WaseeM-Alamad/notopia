"use client";
import React, { memo, useCallback, useEffect, useRef, useState } from "react";
import "@/assets/styles/home.css";
import Note from "./Note";
//icons
import NotesIcon from "./icons/NotesIcon";
import SortByIcon from "./icons/SortByIcon";
import LabelIcon from "./icons/LabelIcon";

const Home = ({ InitialNotes }) => {
  const [ notes, setNotes ] = useState(InitialNotes);

  const containerRef = useRef(null);
  const columnWidth = 260;
  const gutter = 15;

  const calculateLayout = () => {
    const container = containerRef.current;
    const parent = container.parentElement; // Reference to the main div containing padding
    const parentWidth = parent.clientWidth; // Available width inside the main div
    const style = window.getComputedStyle(parent); // Get computed styles
    const paddingLeft = parseFloat(style.paddingLeft) || 0;
    const paddingRight = parseFloat(style.paddingRight) || 0;
    const availableWidth = parentWidth - paddingLeft - paddingRight; // Adjusted width

    const columns = Math.max(
      1,
      Math.floor(availableWidth / (columnWidth + gutter))
    ); // Ensure at least 1 column
    const contentWidth = columns * (columnWidth + gutter) - gutter; // Total content width

    // Center the container
    container.style.width = `${contentWidth}px`;
    container.style.position = "relative";
    container.style.left = "50%";
    container.style.transform = "translateX(-50%)";

    const items = container.children;

    const pinnedItems = Array.from(items).filter(
      (item) => item.dataset.pinned === "true"
    );
    const unpinnedItems = Array.from(items).filter(
      (item) => item.dataset.pinned === "false"
    );

    const positionItems = (itemList, startY = 0) => {
      const columnHeights = new Array(columns).fill(startY);

      itemList.forEach((item) => {
        const minColumnIndex = columnHeights.indexOf(
          Math.min(...columnHeights)
        );
        const x = minColumnIndex * (columnWidth + gutter);
        const y = columnHeights[minColumnIndex];

        item.style.transform = `translate(${x}px, ${y}px)`;
        item.style.position = "absolute";

        columnHeights[minColumnIndex] += item.offsetHeight + gutter;
      });

      return Math.max(...columnHeights);
    };

    const gapBetweenSections = pinnedItems.length > 0 ? 120 : 0;
    // Position pinned items first
    const pinnedHeight = positionItems(pinnedItems);

    // Position unpinned items below pinned items
    const unpinnedHeight = positionItems(
      unpinnedItems,
      pinnedHeight + gapBetweenSections
    );

    // Set container height to fit all items
    container.style.height = `${unpinnedHeight}px`;
  };

  // Recalculate layout on state changes or resize
  useEffect(() => {
    calculateLayout();
    const debouncedResize = debounce(calculateLayout, 400);
    window.addEventListener("resize", debouncedResize);

    return () => window.removeEventListener("resize", debouncedResize);
  }, [notes]);

  // Debounce function to limit recalculations
  function debounce(func, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), delay);
    };
  }

  const togglePin = useCallback((uuid) => {
    setNotes((prevNotes) =>
      prevNotes.map((note) =>
        note.uuid === uuid ? { ...note, isPinned: !note.isPinned } : note
      )
    );
  }, []);

  // const togglePin = useCallback((uuid) => {
  //   setNotes((prevNotes) => {
  //     // Find the note to toggle
  //     const toggledNote = prevNotes.find((note) => note.uuid === uuid);

  //     // Remove the toggled note from the list
  //     const remainingNotes = prevNotes.filter((note) => note.uuid !== uuid);

  //     if (toggledNote.isPinned) {
  //       // If the note was pinned, unpin it and add it to the start of unpinned notes
  //       return [{ ...toggledNote, isPinned: false }, ...remainingNotes];
  //     } else {
  //       // If the note was unpinned, pin it and add it to the start of pinned notes
  //       return [{ ...toggledNote, isPinned: true }, ...remainingNotes];
  //     }
  //   });
  // }, []);

  return (
    <>
      <div className="starting-div">
        <div className="page-header">
          <NotesIcon />
          <h1 className="page-header-title">All Notes</h1>
          <div className="page-header-divider" />
          <div className="divider-tools-container">
            <div className="divider-tool">
              <SortByIcon />
              <span className="divider-tool-text">Sort by</span>
            </div>
            <div className="divider-tool">
              <LabelIcon />
              <span className="divider-tool-text">Labels</span>
            </div>
          </div>
        </div>
        <div ref={containerRef} className="notes-container">
          {notes.map((note) => {
            return (
              <div
                key={note.uuid}
                data-pinned={note.isPinned}
                className="grid-item"
                style={{
                  width: `${columnWidth}px`,
                  marginBottom: `${gutter}px`,
                  transition: "transform 0.2s ease",
                }}
              >
                <Note Note={note} togglePin={togglePin} />
              </div>
            );
          })}
        </div>
      </div>
    </>
  );
};

export default memo(Home);