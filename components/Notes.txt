"use client";
import { fetchNotes } from "@/utils/requests";
import React, { use, useEffect, useRef, useState } from "react";
import CreateNote from "./CreateNote";
import Note from "./Note";
import Isotope from "isotope-layout";
import "@/assets/styles/Notes.css";
import { redirect, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import "@/assets/styles/TopMenu.css";
import { motion, AnimatePresence, color } from "framer-motion";
import { IconButton, Tooltip } from "@mui/material";
import { Category, Close } from "@mui/icons-material";
import TopPin from "./TopPin";
import TopReminder from "./TopReminder";
import TopArchive from "./TopArchive";
import TopMore from "./TopMore";
import ColorSelectMenu from "./ColorSelectMenuTop";

const Notes = ({ initialNotes }) => {
  const [notes, setNotes] = useState(initialNotes);
  const [selectedNotesIDs, setSelectedNotesIDs] = useState([]);
  const [selectedNumber, setSelectedNumber] = useState(0);
  const [updates, setUpdates] = useState({
    isPinned: false,
    isArchived: false,
    color: "#FFFFFF",
  });
  const [colorTrigger, setColorTrigger] = useState(false);
  const [pinTrigger, setPinTrigger] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [selectedColorTop, setSelectedColorTop] = useState("#FFFFFF");
  const isFirstRun = useRef(true);
  const [pinFill, setPinFill] = useState();
  const gridRef = useRef(null);
  const isotopeRef = useRef(null);
  const topMenuRef = useRef(null);
  const noteWrapperRef = useRef(null);
  const ColorMenuRef = useRef(null);
  const SearchParams = useSearchParams();
  const searchTerm = SearchParams.get("Search" || "");
  const { data: session, status } = useSession();
  const userID = session?.user?.id;

  useEffect(() => {
    if (status === "unauthenticated") {
      redirect("/login");
    }
  }, [status]);

  const loadNotes = async () => {
    const fetchedNotes = await fetchNotes(userID);
    setNotes(fetchedNotes);
  };

  useEffect(() => {
    // Update the Isotope layout when notes change
    if (isotopeRef.current) {
      isotopeRef.current.reloadItems();
      isotopeRef.current.arrange();

      isotopeRef.current.arrange({
        sortBy: "Category",
        sortAscending: false,
      });
    }
  }, [notes]);

  useEffect(() => {
    // Initialize Isotope after notes are loaded
    if (gridRef.current) {
      isotopeRef.current = new Isotope(gridRef.current, {
        itemSelector: ".grid-item",
        masonry: {
          columnWidth: 240,
          gutter: 14,
        },
        percentPosition: true,
        horizontalOrder: false,
        transitionDuration: 400,
        stagger: 1,
        layoutMode: "masonry",
        getSortData: {
          Category: "[data-category]",
        },
      });
    }

    // Cleanup the Isotope instance on component unmount
    return () => {
      if (isotopeRef.current) {
        isotopeRef.current.destroy();
      }
    };
  }, []);

  // Optional: handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (isotopeRef.current) {
        isotopeRef.current.arrange();
      }
    };

    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  const [isGridLayout, setIsGridLayout] = useState(false);

  useEffect(() => {
    // Load initial layout preference from localStorage
    const savedLayout = localStorage.getItem("isGridLayout");
    if (savedLayout !== null) {
      setIsGridLayout(JSON.parse(savedLayout));
    }

    // Listen for the custom 'layoutChange' event to update the layout dynamically
    const handleLayoutChange = (event) => {
      setIsGridLayout(event.detail);
    };

    window.addEventListener("layoutChange", handleLayoutChange);

    // Cleanup the event listener on component unmount
    return () => {
      window.removeEventListener("layoutChange", handleLayoutChange);
    };
  }, []);

  useEffect(() => {
    if (isotopeRef.current) {
      setTimeout(() => {
        isotopeRef.current.arrange();
      }, 400);
    }
  }, [isGridLayout]);

  const handleClearSelection = () => {
    setSelectedNotesIDs([]);
  };

  useEffect(() => {
    setSelectedNumber((prev) => {
      if (selectedNotesIDs.length === 0) {
        return prev;
      } else {
        return selectedNotesIDs.length;
      }
    });
  }, [selectedNotesIDs.length]);

  useEffect(() => {
    console.log(selectedNotesIDs);
    if (selectedNotesIDs.length === 0) {
      return;
    }

    const allPinned = selectedNotesIDs.every((note) => note.isPinned);
    setUpdates((prev) => ({ ...prev, isPinned: allPinned }));
    setPinFill(allPinned);

    if (!allPinned) {
      setUpdates((prev) => ({ ...prev, isPinned: false }));
    }
  }, [selectedNotesIDs.length, selectedNotesIDs]);

  useEffect(() => {
    const handler = (event) => {
      const target = event.target.closest(
        ".pinned-grid-item, .grid-item, .top-menu"
      );

      if (!target && selectedNotesIDs.length > 0) {
        setSelectedNotesIDs([]);
      }
    };

    document.addEventListener("mousedown", handler);

    return () => {
      document.removeEventListener("mousedown", handler);
    };
  }, [selectedNotesIDs.length]);

  const updateSelectedNotesIDs = async (updates) => {
    try {
      const formData = new FormData();
      formData.append(
        "selectedNotesIDs",
        selectedNotesIDs.map((note) => note.uuid).join(",")
      );

      if (updates.hasOwnProperty("isPinned"))
        formData.append("isPinned", updates.isPinned);
      if (updates.hasOwnProperty("isArchived"))
        formData.append("isArchived", updates.isArchived);
      if (updates.hasOwnProperty("color"))
        formData.append("color", updates.color);

      const response = await fetch("/api/notes/batch-update", {
        method: "PATCH",
        body: formData,
      });

      if (!response.ok) {
        throw new Error("Failed to update notes");
      }
    } catch (error) {
      console.error("Error updating notes:", error);
    }
  };

  const handleColorSelect = (color) => {
    setSelectedColorTop(color);
    setColorTrigger((prev) => !prev);
    setUpdates((prev) => ({ ...prev, color: color }));
    const update = { color: color };
    updateSelectedNotesIDs(update);
  };

  return (
    <>
      <AnimatePresence>
        <motion.div
          ref={topMenuRef}
          className="top-menu"
          initial={{ opacity: 0, y: -20 }}
          animate={{
            opacity: selectedNotesIDs.length > 0 ? 1 : 0,
            y: selectedNotesIDs.length > 0 ? 0 : -20,
            visibility: selectedNotesIDs.length > 0 ? "visible" : "hidden",
          }}
          transition={{
            opacity: { duration: 0.2, ease: "easeInOut" },
            y: { duration: 0.3, stiffness: 130, damping: 20 },
          }}
        >
          <Tooltip title="Clear selection">
            <IconButton
              onClick={handleClearSelection}
              sx={{
                "&:hover": { backgroundColor: "rgba(0,0,0,0.1)" },
                marginLeft: "0.2em",
              }}
              disableTouchRipple
            >
              <Close sx={{ padding: "8.5px" }} />
            </IconButton>
          </Tooltip>
          <h2 className="selected"> {selectedNumber} Selected </h2>
          <div className="top-menu-tools">
            <Tooltip title="Pin note" disableInteractive>
              <IconButton
                sx={{
                  "&:hover": { backgroundColor: "rgba(0,0,0,0.1)" },
                  padding: "10.5px",
                }}
                disableTouchRipple
                onClick={() => {
                  setPinTrigger((prev) => !prev);
                  isotopeRef.current.arrange({
                    sortBy: "Category",
                    sortAscending: false,
                  });
                
                  const newIsPinned = !updates.isPinned;
                  setUpdates((prev) => ({ ...prev, isPinned: newIsPinned }));
                  setPinFill(newIsPinned);
                  updateSelectedNotesIDs({ isPinned: newIsPinned });
                  setSelectedNotesIDs([]);
                }}
              >
                <TopPin pinFill={pinFill} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Remind me" disableInteractive>
              <IconButton
                sx={{
                  "&:hover": { backgroundColor: "rgba(0,0,0,0.1)" },
                  padding: "10.5px",
                }}
                disableTouchRipple
              >
                <TopReminder />
              </IconButton>
            </Tooltip>

            <ColorSelectMenu
              ColorMenuRef={ColorMenuRef}
              isOpen={isOpen}
              setIsOpen={setIsOpen}
              handleColorSelect={handleColorSelect}
              selectedColorTop={selectedColorTop}
              setSelectedColorTop={setSelectedColorTop}
            />

            <Tooltip title="Archive" disableInteractive>
              <IconButton
                sx={{
                  "&:hover": { backgroundColor: "rgba(0,0,0,0.1)" },
                  padding: "10.5px",
                }}
                disableTouchRipple
                onClick={() => {
                  const update = { isArchived: !updates.isArchived };
                  setUpdates((prev) => ({
                    ...prev,
                    isPinned: !prev.isArchived,
                  }));
                  updateSelectedNotesIDs(update);
                }}
              >
                <TopArchive />
              </IconButton>
            </Tooltip>
            <Tooltip title="More" disableInteractive>
              <IconButton
                sx={{
                  "&:hover": { backgroundColor: "rgba(0,0,0,0.1)" },
                  padding: "10.5px",
                }}
                disableTouchRipple
              >
                <TopMore />
              </IconButton>
            </Tooltip>
          </div>
        </motion.div>
      </AnimatePresence>

      <div className="content-wrapper">
        <CreateNote setNotes={setNotes} />

        <div className="notes-wrapper">
          <div
            style={{
              width: isGridLayout ? "37.5rem" : "98%",
            }}
            className="inner-notes-wrapper"
          >
            <div ref={gridRef} className="grid">
              {[...notes].reverse().map((note) => {
                return (
                  <div
                    ref={noteWrapperRef}
                    key={note.uuid}
                    className={`grid-item`}
                    data-category={note.isPinned ? "B" : "A"}
                  >
                    <Note
                      selectedNotesIDs={selectedNotesIDs}
                      setSelectedNotesIDs={setSelectedNotesIDs}
                      isGridLayout={isGridLayout}
                      note={note}
                      updates={updates}
                      colorTrigger={colorTrigger}
                      pinTrigger={pinTrigger}
                      setNotes={setNotes}
                      userID={userID}
                    />
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default Notes;
