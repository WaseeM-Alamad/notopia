"use client";
import Modal from "@/components/others/Modal";
import Archive from "@/components/pages/Archive";
import Labels from "@/components/pages/Labels";
import Home from "@/components/pages/Home";
import Reminders from "@/components/pages/Reminders";
import Trash from "@/components/pages/Trash";
import Snackbar from "@/components/Tools/Snackbar";
import Tooltip from "@/components/Tools/Tooltip";
import {
  DeleteNoteAction,
  fetchNotes,
  NoteUpdateAction,
  undoAction,
} from "@/utils/actions";
import { AnimatePresence, motion } from "framer-motion";
import React, {
  memo,
  useCallback,
  useEffect,
  useReducer,
  useRef,
  useState,
} from "react";
import { useAppContext } from "@/context/AppContext";

const initialStates = {
  notes: new Map(),
  order: [],
};

function notesReducer(state, action) {
  switch (action.type) {
    case "SET_INITIAL_DATA":
      return {
        ...state,
        notes: action.notes,
        order: action.order,
      };

    case "ADD_NOTE":
      return {
        ...state,
        notes: new Map(state.notes).set(action.newNote.uuid, action.newNote),
        order: [action.newNote.uuid, ...state.order],
      };

    case "PIN_NOTE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isPinned: !action.note.isPinned,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.note.uuid
      );
      return {
        ...state,
        notes: updatedNotes,
        order: [action.note.uuid, ...updatedOrder],
      };
    }
    case "ARCHIVE_NOTE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isArchived: !action.note.isArchived,
        isPinned: false,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.note.uuid
      );
      return {
        ...state,
        notes: updatedNotes,
        order: [action.note.uuid, ...updatedOrder],
      };
    }
    case "UNDO_ARCHIVE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isArchived: action.note.isArchived,
        isPinned: action.note.isPinned,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order];
      const [targetedNote] = updatedOrder.splice(0, 1);
      updatedOrder.splice(action.initialIndex, 0, targetedNote);

      return {
        ...state,
        notes: updatedNotes,
        order: updatedOrder,
      };
    }
    case "TRASH_NOTE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isTrash: !action.note.isTrash,
        isPinned: false,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.note.uuid
      );
      return {
        ...state,
        notes: updatedNotes,
        order: [action.note.uuid, ...updatedOrder],
      };
    }
    case "UNDO_TRASH": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isTrash: action.note.isTrash,
        isPinned: action.note.isPinned,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order];
      const [targetedNote] = updatedOrder.splice(0, 1);
      updatedOrder.splice(action.initialIndex, 0, targetedNote);

      return {
        ...state,
        notes: updatedNotes,
        order: updatedOrder,
      };
    }
    case "DELETE_NOTE": {
      const newNotes = new Map(state.notes);
      newNotes.delete(action.note.uuid);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.note.uuid
      );
      return {
        ...state,
        notes: newNotes,
        order: updatedOrder,
      };
    }
    case "PIN_ARCHIVED_NOTE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isPinned: true,
        isArchived: false,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.note.uuid
      );
      return {
        ...state,
        notes: updatedNotes,
        order: [action.note.uuid, ...updatedOrder],
      };
    }
    case "UNDO_PIN_ARCHIVED": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        isPinned: false,
        isArchived: true,
      };

      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);

      const updatedOrder = [...state.order];
      const [targetedNote] = updatedOrder.splice(0, 1);
      updatedOrder.splice(action.initialIndex, 0, targetedNote);

      return {
        ...state,
        notes: updatedNotes,
        order: updatedOrder,
      };
    }
    case "UPDATE_COLOR": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        color: action.newColor,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);

      return {
        ...state,
        notes: updatedNotes,
      };
    }
    case "ADD_IMAGE": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        images: [
          ...action.note.images,
          { url: action.imageURL, uuid: action.newImageUUID },
        ],
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);

      return {
        ...state,
        notes: updatedNotes,
      };
    }
    case "UPDATE_TEXT": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        title: action.newTitle,
        content: action.newContent,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      return {
        ...state,
        notes: updatedNotes,
      };
    }
    case "UPDATE_IMAGES": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        images: action.newImages,
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      return {
        ...state,
        notes: updatedNotes,
      };
    }

    case "UNDO_COPY": {
      const updatedNotes = new Map(state.notes);
      updatedNotes.delete(action.noteUUID);
      const updatedOrder = [...state.order].filter(
        (uuid) => uuid !== action.noteUUID
      );

      return {
        ...state,
        notes: updatedNotes,
        order: updatedOrder,
      };
    }

    case "ADD_LABEL": {
      const newNote = {
        ...state.notes.get(action.note.uuid),
        labels: [...action.note.labels, action.labelUUID],
      };
      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      return {
        ...state,
        notes: updatedNotes,
      };
    }

    case "REMOVE_LABEL": {
      const targetedNote = {
        ...state.notes.get(action.note.uuid),
      };

      const newNote = {
        ...targetedNote,
        labels: targetedNote.labels.filter(
          (noteLabelUUID) => noteLabelUUID !== action.labelUUID
        ),
      };

      const updatedNotes = new Map(state.notes).set(action.note.uuid, newNote);
      return {
        ...state,
        notes: updatedNotes,
      };
    }

    case "REMOVE_LABEL_FROM_NOTES": {
      const updatedNotes = new Map(state.notes);
      state.order.map((noteUUID) => {
        const note = state.notes.get(noteUUID);
        note.labels = note.labels.filter(
          (noteLabelUUID) => noteLabelUUID !== action.labelUUID
        );
        updatedNotes.set(noteUUID, note);
      });
      return {
        ...state,
        notes: updatedNotes,
      };
    }

    case "EMPTY_TRASH": {
      const updatedNotes = new Map();
      const updatedOrder = [];

      for (const noteUUID of state.order) {
        const note = state.notes.get(noteUUID);
        if (!note.isTrash) {
          updatedNotes.set(noteUUID, note);
          updatedOrder.push(noteUUID);
        }
      }

      return {
        ...state,
        notes: updatedNotes,
        order: updatedOrder,
      };
    }

    case "DND": {
      return {
        ...state,
        order: action.updatedOrder,
      };
    }
  }
}

const page = () => {
  const { batchDecNoteCount } = useAppContext();
  const [currentPage, setCurrentPage] = useState();
  const [tooltipAnchor, setTooltipAnchor] = useState(null);
  const [notesState, dispatchNotes] = useReducer(notesReducer, initialStates);
  const [modalStyle, setModalStyle] = useState(null);
  const [selectedNote, setSelectedNote] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [snackbarState, setSnackbarState] = useState({
    snackOpen: false,
    showUndo: true,
    message: "",
  });
  const [unloadWarn, setUnloadWarn] = useState(false);
  const undoFunction = useRef(() => {});
  const onCloseFunction = useRef(() => {});
  const closeRef = useRef(null);

  const openSnackFunction = useCallback((data) => {
    if (data.close) {
      setSnackbarState((prev) => ({
        ...prev,
        snackOpen: false,
      }));
      onCloseFunction.current();
    } else {
      setSnackbarState((prev) => ({
        ...prev,
        snackOpen: false,
      }));
      onCloseFunction.current();

      setTimeout(() => {
        setSnackbarState({
          message: data.snackMessage,
          showUndo: true,
          snackOpen: true,
        });
        if (data.snackOnUndo !== undefined) {
          undoFunction.current = data.snackOnUndo;
        }
        if (data.snackOnClose !== undefined) {
          onCloseFunction.current = data.snackOnClose;
        }
        if (data.unloadWarn) {
          setUnloadWarn(true);
        }
      }, 80);
    }
  }, []);

  const closeSnackbar = () => {
    setSnackbarState((prev) => ({
      ...prev,
      snackOpen: false,
    }));
    onCloseFunction.current();
  };

  useEffect(() => {
    const handler = () => {
      openSnackFunction({ close: true });
    };

    window.addEventListener("sectionChange", handler);

    return () => window.removeEventListener("sectionChange", handler);
  }, []);

  useEffect(() => {
    const handleBeforeUnload = (event) => {
      if (unloadWarn) {
        const message =
          "Your request is still in progress. Are you sure you want to leave?";
        event.returnValue = message;
        return message;
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [unloadWarn]);

  useEffect(() => {
    const handleHashChange = () => {
      const currentHash = window.location.hash;

      setTooltipAnchor(null);
      setTimeout(() => {
        setCurrentPage(currentHash);
      }, 0);
    };

    handleHashChange();

    window.addEventListener("hashchange", handleHashChange);

    // Cleanup event listener on component unmount
    return () => {
      window.removeEventListener("hashchange", handleHashChange);
    };
  }, []);

  const getNotes = async () => {
    window.dispatchEvent(new Event("loadingStart"));
    const fetchedNotes = await fetchNotes();
    // console.log("initial notes", fetchedNotes.data)
    window.dispatchEvent(new Event("loadingEnd"));

    const notesMap = new Map(
      fetchedNotes.data.map((note) => [note.uuid, note])
    );
    dispatchNotes({
      type: "SET_INITIAL_DATA",
      notes: notesMap,
      order: fetchedNotes.order,
    });
  };

  useEffect(() => {
    getNotes();
    window.addEventListener("refresh", getNotes);

    return () => window.removeEventListener("refresh", getNotes);
  }, []);

  const handleNoteClick = useCallback((e, note, index) => {
    if (
      e.target.closest("button") ||
      !e.currentTarget.classList.contains("grid-item")
    )
      return;
    const element = e.currentTarget;

    requestAnimationFrame(() => {
      const rect = element.getBoundingClientRect();
      setModalStyle({
        index: index,
        element: element,
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}`,
        height: `${rect.height}`,
      });

      setTimeout(() => {
        setSelectedNote(note);
        setIsModalOpen(true);
        element.style.opacity = "0";
      }, 20);
    });
  }, []);

  const noteActions = useCallback(async (data) => {
    if (data.type === "archive") {
      const initialIndex = data.index;

      const handler = (e) => {
        if (e.propertyName === "opacity") {
          data.noteRef.current.removeEventListener("transitionend", handler);

          dispatchNotes({
            type: "ARCHIVE_NOTE",
            note: data.note,
          });
        }
      };

      data.noteRef.current.addEventListener("transitionend", handler);
      data.noteRef.current.offsetHeight;
      data.noteRef.current.classList.add("fade-out");

      const undoArchive = async () => {
        dispatchNotes({
          type: "UNDO_ARCHIVE",
          note: data.note,
          initialIndex: initialIndex,
        });
        window.dispatchEvent(new Event("loadingStart"));
        await undoAction({
          type: "UNDO_ARCHIVE",
          noteUUID: data.note.uuid,
          value: data.note.isArchived,
          pin: data.note.isPinned,
          initialIndex: initialIndex,
          endIndex: 0,
        });
        window.dispatchEvent(new Event("loadingEnd"));
      };
      openSnackFunction({
        snackMessage: `${
          data.note.isArchived
            ? "Note unarchived"
            : data.note.isPinned
            ? "Note unpinned and archived"
            : "Note Archived"
        }`,
        snackOnUndo: undoArchive,
      });
      const first = data.index === 0;
      window.dispatchEvent(new Event("loadingStart"));
      await NoteUpdateAction(
        "isArchived",
        !data.note.isArchived,
        data.note.uuid,
        first
      );
      window.dispatchEvent(new Event("loadingEnd"));
    } else if (data.type === "TRASH_NOTE") {
      const handler = (e) => {
        if (e.propertyName === "opacity") {
          data.noteRef.current.removeEventListener("transitionend", handler);
          dispatchNotes({
            type: "TRASH_NOTE",
            note: data.note,
          });
        }
      };

      data.noteRef.current.addEventListener("transitionend", handler);
      data.noteRef.current.classList.add("fade-out");

      const initialIndex = data.index;
      const undoTrash = async () => {
        dispatchNotes({
          type: "UNDO_TRASH",
          note: data.note,
          initialIndex: initialIndex,
        });

        window.dispatchEvent(new Event("loadingStart"));
        await undoAction({
          type: "UNDO_TRASH",
          noteUUID: data.note.uuid,
          value: true,
          initialIndex: data.initialIndex,
          endIndex: 0,
        });
        window.dispatchEvent(new Event("loadingEnd"));
      };

      openSnackFunction({
        snackMessage: "Note restored",
        snackOnUndo: undoTrash,
      });

      window.dispatchEvent(new Event("loadingStart"));
      await NoteUpdateAction("isTrash", false, data.note.uuid);
      window.dispatchEvent(new Event("loadingEnd"));
    } else if (data.type === "RESTORE_NOTE") {
      const handler = (e) => {
        if (e.propertyName === "opacity") {
          data.noteRef.current.removeEventListener("transitionend", handler);
          dispatchNotes({
            type: "TRASH_NOTE",
            note: data.note,
          });
        }
      };

      data.noteRef.current.addEventListener("transitionend", handler);
      data.noteRef.current.classList.add("fade-out");

      const initialIndex = data.index;
      const undoTrash = async () => {
        dispatchNotes({
          type: "UNDO_TRASH",
          note: data.note,
          initialIndex: initialIndex,
        });
      };

      const onClose = async () => {
        window.dispatchEvent(new Event("loadingStart"));
        await NoteUpdateAction("isTrash", true, data.note.uuid);
        window.dispatchEvent(new Event("loadingEnd"));
      };

      if (!data.note.isTrash) {
        openSnackFunction({
          snackMessage: `${
            data.note.isPinned ? "Note unpinned and trashed" : "Note trashed"
          }`,
          snackOnUndo: undoTrash,
          snackOnClose: onClose,
          unloadWarn: true,
        });
      }
      data.setIsOpen(false);
    } else if (data.type === "DELETE_NOTE") {
      batchDecNoteCount(data.note.labels);

      const handler = (e) => {
        if (e.propertyName === "opacity") {
          data.noteRef.current.removeEventListener("transitionend", handler);
          dispatchNotes({
            type: "DELETE_NOTE",
            note: data.note,
          });
        }
      };

      data.noteRef.current.addEventListener("transitionend", handler);
      data.noteRef.current.classList.add("fade-out");

      window.dispatchEvent(new Event("loadingStart"));
      await DeleteNoteAction(data.note.uuid);
      window.dispatchEvent(new Event("loadingEnd"));
    } else if (data.type === "PIN_ARCHIVED_NOTE") {
      const handler = (e) => {
        if (e.propertyName === "opacity") {
          data.noteRef.current.removeEventListener("transitionend", handler);
          dispatchNotes({
            type: "PIN_ARCHIVED_NOTE",
            note: data.note,
          });
        }
      };

      data.noteRef.current.addEventListener("transitionend", handler);
      data.noteRef.current.classList.add("fade-out");

      window.dispatchEvent(new Event("loadingStart"));
      const initialIndex = data.index;

      const undoPinArchived = async () => {
        dispatchNotes({
          type: "UNDO_PIN_ARCHIVED",
          note: data.note,
          initialIndex: initialIndex,
        });

        window.dispatchEvent(new Event("loadingStart"));
        await undoAction({
          type: "UNDO_PIN_ARCHIVED",
          noteUUID: data.note.uuid,
          initialIndex: initialIndex,
          endIndex: 0,
        });
        window.dispatchEvent(new Event("loadingEnd"));
      };

      openSnackFunction({
        snackMessage: "Note unarchived and pinned",
        snackOnUndo: undoPinArchived,
      });

      try {
        await NoteUpdateAction("pinArchived", true, data.note.uuid);
      } finally {
        window.dispatchEvent(new Event("loadingEnd"));
      }
    } else if (data.type === "UPDATE_COLOR") {
      if (data.newColor === data.selectedColor) return;
      data.setSelectedColor(data.newColor);

      dispatchNotes({
        type: "UPDATE_COLOR",
        note: data.note,
        newColor: data.newColor,
      });

      window.dispatchEvent(new Event("loadingStart"));
      await NoteUpdateAction("color", data.newColor, data.note.uuid);
      window.dispatchEvent(new Event("loadingEnd"));
    }
  }, []);

  if (currentPage === null) return;

  const Header = memo(() => <div className="starting-div-header" />);

  Header.displayName = "Header";

  const renderPage = () => { 
    if (currentPage?.includes("trash"))
      return (
        <Trash
          dispatchNotes={dispatchNotes}
          notes={notesState.notes}
          noteActions={noteActions}
          order={notesState.order}
          setTooltipAnchor={setTooltipAnchor}
          openSnackFunction={openSnackFunction}
        />
      );
    else if (currentPage?.includes("home"))
      return (
        <Home
          dispatchNotes={dispatchNotes}
          notes={notesState.notes}
          order={notesState.order}
          setTooltipAnchor={setTooltipAnchor}
          openSnackFunction={openSnackFunction}
          noteActions={noteActions}
          handleNoteClick={handleNoteClick}
        />
      );
    else if (currentPage?.includes("labels"))
      return (
        <Labels
          setTooltipAnchor={setTooltipAnchor}
          dispatchNotes={dispatchNotes}
          openSnackFunction={openSnackFunction}
        />
      );
    else if (currentPage?.includes("archive"))
      return (
        <Archive
          dispatchNotes={dispatchNotes}
          notes={notesState.notes}
          order={notesState.order}
          setTooltipAnchor={setTooltipAnchor}
          openSnackFunction={openSnackFunction}
          noteActions={noteActions}
        />
      );
    else if (currentPage?.includes("reminders")) return <Reminders />;
    else
      return (
        <Home
          dispatchNotes={dispatchNotes}
          notes={notesState.notes}
          order={notesState.order}
          setTooltipAnchor={setTooltipAnchor}
          openSnackFunction={openSnackFunction}
          handleNoteClick={handleNoteClick}
          noteActions={noteActions}
        />
      );
  };

  return (
    <>
      <AnimatePresence>
        {isModalOpen && (
          <motion.div
            initial={{
              opacity: 0,
              display: "none",
              backgroundColor: "rgba(0,0,0,0.0)",
            }}
            animate={{
              opacity: 1,
              display: "block",
              backgroundColor: "rgba(0,0,0,0.5)",
            }}
            exit={{
              opacity: 0,
              display: "none",
              backgroundColor: "rgba(0,0,0,0.0)",
            }}
            transition={{
              all: {
                type: "spring",
                stiffness: 1000,
                damping: 50,
                mass: 1,
              },
            }}
            onClick={() => {
              setIsModalOpen(false);
            }}
            className="modal-container no-transition"
          />
        )}
      </AnimatePresence>

      <Modal
        note={selectedNote}
        dispatchNotes={dispatchNotes}
        initialStyle={modalStyle}
        onClose={() => setSelectedNote(null)}
        setTooltipAnchor={setTooltipAnchor}
        closeRef={closeRef}
        isOpen={isModalOpen}
        setIsOpen={setIsModalOpen}
        openSnackFunction={openSnackFunction}
        closeSnackbar={closeSnackbar}
        setModalStyle={setModalStyle}
      />
      {tooltipAnchor?.display && <Tooltip anchorEl={tooltipAnchor} />}
      <Snackbar
        snackbarState={snackbarState}
        setSnackbarState={setSnackbarState}
        setTooltipAnchor={setTooltipAnchor}
        undo={undoFunction}
        unloadWarn={unloadWarn}
        setUnloadWarn={setUnloadWarn}
        onClose={onCloseFunction}
      />
      <Header />
      {renderPage()}
    </>
  );
};

export default page;
